#!/bin/bash

# {Project Scripts} : "pawnclis_windows" - for Windows
# {Copyright} GNU GPL Version 3, 29 June 2007 ("maintainers") ("2025")

if [ ! -f "data.json" ]; then
    cat > data.json <<EOF
{
    "amx_opt": "-d0",
    "allow_subdir": "/pawno/include",
    "ppman_dir": "pawno",
    "ppman_subdir": "include",
    "ppman_type": "urllib3",
    "ai_token": "",
    "ai_model": "",
    "ai_biodata": "",
    "ai_json_get": ""
}
EOF
fi

##################################################################
AMX_OPT_F=$(grep '"amx_opt"' data.json | sed -E 's/.*"amx_opt": "(.*)".*/\1/')
##################################################################

# @pawn-lang compiler 3.10.7^ - ("https://github.com/pawn-lang/compiler")

# Usage:   pawncc <filename> [filename...] [options]
# Options:
#        -A<num>  alignment in bytes of the data segment and the stack
#        -a       output assembler code
#        -C[+/-]  compact encoding for output file (default=+)
#        -c<name> codepage name or number; e.g. 1252 for Windows Latin-1
#        -Dpath   active directory path
#        -d<num>  debugging level (default=-d1)
#            0    no symbolic information, no run-time checks
#            1    run-time checks, no symbolic information
#            2    full debug information and dynamic checking
#            3    same as -d2, but implies -O0
#        -e<name> set name of error file (quiet compile)
#        -H<hwnd> window handle to send a notification message on finish
#        -i<name> path for include files
#        -l       create list file (preprocess only)
#        -o<name> set base name of (P-code) output file
#        -O<num>  optimization level (default=-O1)
#            0    no optimization
#            1    JIT-compatible optimizations only
#            2    full optimizations
#        -p<name> set name of "prefix" file
#        -R[+/-]  add detailed recursion report with call chains (default=-)
#        -r[name] write cross reference report to console or to specified file
#        -S<num>  stack/heap size in cells (default=4096)
#        -s<num>  skip lines from the input file
#        -t<num>  TAB indent size (in character positions, default=8)
#        -v<num>  verbosity level; 0=quiet, 1=normal, 2=verbose (default=1)
#        -w<num>  disable a specific warning by its number
#        -X<num>  abstract machine size limit in bytes
#        -XD<num> abstract machine data/stack size limit in bytes
#        -Z[+/-]  run in compatibility mode (default=-)
#        -E[+/-]  turn warnings in to errors
#        -\       use '\' for escape characters
#        -^       use '^' for escape characters
#        -;[+/-]  require a semicolon to end each statement (default=-)
#        -([+/-]  require parantheses for function invocation (default=-)
#        sym=val  define constant "sym" with value "val"
#        sym=     define constant "sym" with value 0

if [ ! -d .cache ]; then
    mkdir .cache
fi

_DIR1=$(awk -F'"' '/"ppman_dir"/ {print $4}' data.json)
_DIR2=$(awk -F'"' '/"ppman_subdir"/ {print $4}' data.json)

ALLOW_INC_DIR="/$_DIR1/$_DIR2"
_ALLOW_INC_DIR="$_DIR1/$_DIR2"

if [ ! -d "$_DIR1" ]; then
    mkdir -p "$_ALLOW_INC_DIR"
fi

METADAT_FILE=".cache/compiler.log"

SHUSERS="$USER@$(hostname)"

bash_title() {
    echo -ne "\033]0;$1\007"
}

bash_title "$SHUSERS:~"

BASH_DIR="$(dirname "$0")"
BASH_TITLE=""
BASH_NAME="pawnclis"
BASH_SERVER="samp-server.exe"
BASH_BUILD="0.0.1-b3"

BASH_ALLOW_SDIR=$(grep '"allow_subdir"' data.json | sed -E 's/.*"allow_subdir": "(.*)".*/\1/')

COMPILER_MODE=false
BASH_SEND_SAMP_STATUS=0
BASH_SEND_PAWNCC_STATUS=0
COMPILER_PAWNCC=""

# ["https://groq.com/"]
AI_TOKEN=$(grep '"ai_token"' data.json | sed -E 's/.*"ai_token": "(.*)".*/\1/')
AI_MODEL=$(grep '"ai_model"' data.json | sed -E 's/.*"ai_model": "(.*)".*/\1/')
AI_BIODATA=$(grep '"ai_biodata"' data.json | sed -E 's/.*"ai_biodata": "(.*)".*/\1/')
AI_JSON_GET=$(grep '"ai_json_get"' data.json | sed -E 's/.*"ai_json_get": "(.*)".*/\1/')
    # "python"
    # "python3"
    # "sed"
    # "jq"
    # "grep"

PPMAN_INSTALLER=$(grep '"ppman_type"' data.json | sed -E 's/.*"ppman_type": "(.*)".*/\1/')
    # "urllib3",
    # "curl"

URL_DOWNLOAD="https://raw.githubusercontent.com/vilksons/pawnclis/refs/heads/main/PawnCLIS/pawnclis_win"

COLOR_Y="\e[33m"
COLOR_G="\e[32m"
COLOR_R="\e[31m"

function bash_coltext_y() {
    local color="$COLOR_Y"
    local text="$1"
    echo -e "${color}${text}\e[0m"
}

function bash_coltext_g() {
    local color="$COLOR_G"
    local text="$1"
    echo -e "${color}${text}\e[0m"
}

function bash_coltext_r() {
    local color="$COLOR_R"
    local text="$1"
    echo -e "${color}${text}\e[0m"
}

function bash_typeof() {
    echo -n "$(bash_coltext_y "$SHUSERS")"
    echo -n ":~$ "
    read -r OPBASH_F
    bash_next
}

function bash_typeof2() {
    echo -n "$(bash_coltext_y "$SHUSERS")"
    echo -n ":~$ "
    read -r OPBASH_PF
    packageManager
}

bash_next() {
    local BASH_OPTION="paw"

    case "$OPBASH_F" in
        "$BASH_OPTION -c")
            killall -9 "samp-server.exe" >/dev/null 2>&1
            BASH_TITLE="compilers"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            echo
            COMPILER_MODE=true
            bash_compilers
            ;;
        "$BASH_OPTION -r")
            killall -9 "samp-server.exe" >/dev/null 2>&1
            BASH_TITLE="running"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            sleep 0
            bash_servers
            ;;
        "$BASH_OPTION -d")
            BASH_TITLE="samp server debugger"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            bash_testservers
            ;;
        "$BASH_OPTION -s")
            killall -9 "samp-server.exe" >/dev/null 2>&1
            bash_end
            ;;
        "$BASH_OPTION -u")
            killall -9 "samp-server.exe" >/dev/null 2>&1
            BASH_TITLE="compile running"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            COMPILER_MODE=false
            echo
            compilers
            if grep -i "error" "$METADAT_FILE" >/dev/null; then
                echo
            else
                ok_next
            fi
            ;;
        "$BASH_OPTION -g") 
            BASH_SEND_SAMP_STATUS=0
            bash_send_samp
            ;;
        "$BASH_OPTION -p") 
            BASH_SEND_PAWNCC_STATUS=0
            bash_send_compiler
            ;;
        "$BASH_OPTION -C")
            BASH_TITLE="clear screen"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            clear
            bash_typeof
            ;;
        "$BASH_OPTION -V")
            BASH_TITLE="vscode tasks"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            if [ -d ".vscode" ]; then
                rm -rf .vscode
            fi
            mkdir .vscode
            cat <<EOF > .vscode/tasks.json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Run PawnCLIS",
      "type": "process",
      "command": "\${workspaceFolder}/$BASH_NAME",
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": [],
      "detail": "Task to run the PawnCLIS"
    }
  ]
}
EOF
            echo "OK? '.vscode/tasks.json'...: [yes]"
            bash_end
            ;;
        "$BASH_OPTION -F")
            BASH_TITLE="folder check"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            CHECK_FOL_NOW "filterscripts"
            CHECK_FOL_NOW "gamemodes"
            CHECK_FOL_NOW "scriptfiles"
            if [ -f "server.cfg" ]; then
                echo
                echo "# server.cfg is .. Ok .."
                echo " [A subdirectory or file server.cfg already exists.]"
            else
                cat <<EOF > server.cfg
echo Executing Server Config...
lanmode 0
rcon_password changename
maxplayers 150
port 7777
hostname SA-MP 0.3
gamemode0 main 1
filterscripts
announce 0
chatlogging 0
weburl www.sa-mp.com
onfoot_rate 40
incar_rate 40
weapon_rate 40
stream_distance 300.0
stream_rate 1000
maxnpc 0
logtimeformat [%H:%M:%S]
language English
EOF
                echo "OK? '$BASH_DIR/server.cfg'...: [yes]"
                echo
                cat server.cfg
                echo
                bash_end
            fi
            ;;
        "$BASH_OPTION -v")
            BASH_TITLE="version"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            echo
            echo "~ $BASH_BUILD"
            echo
            bash_end
            ;;
        "$BASH_OPTION -T")
            BASH_TITLE="type files"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            echo "Example: ~ server.cfg server_log.txt"
            read -r -p "~ " inputTYPES
            cat "$inputTYPES"
            echo
            bash_end
            ;;
        "$BASH_OPTION -D")
            ls
            ;;
        "$BASH_OPTION -K")
            chmod +x $BASH_NAME
            bash ./$BASH_NAME
            ;;
        "$BASH_OPTION -U")
            BASH_TITLE="Update"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            cd "$BASH_DIR" || bash_end
            curl -L --progress-bar -o "$BASH_NAME" "$URL_DOWNLOAD"
            clear
            chmod +x $BASH_NAME
            bash ./$BASH_NAME
            ;;
        "$BASH_OPTION -S")
            BASH_TITLE="Checksums"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            cd "$BASH_DIR" || bash_end
            sha1sum $BASH_NAME
            sha256sum $BASH_NAME
            md5sum $BASH_NAME
            ;;
        "$BASH_OPTION -W")
            whoami
            bash_end
            ;;
        "$BASH_OPTION -e")
            bash
            ;;
        "$BASH_OPTION -a")
            read -r -p "Quest: " user_question
    
            if [[ "$user_question" == "exit" ]]; then
                echo "..close."
                bash_end
            fi

            echo "*typing..."

            response=$(curl -s -X POST https://api.groq.com/openai/v1/chat/completions \
                -H "Authorization: Bearer $AI_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                    \"model\": \"$AI_MODEL\",
                    \"messages\": [
                        {
                        \"role\": \"system\",
                        \"content\": \"$AI_BIODATA\"
                        },
                        {
                        \"role\": \"user\",
                        \"content\": \"$user_question\"
                        }
                    ],
                    \"temperature\": 1,
                    \"max_tokens\": 1024,
                    \"top_p\": 1,
                    \"stream\": false,
                    \"stop\": null
                    }")

            if [ "$AI_JSON_GET" == "python" ]; then
                echo "$response" | python -c "import sys, json; print(json.load(sys.stdin)['choices'][0]['message']['content'])"
            elif [ "$AI_JSON_GET" == "python3" ]; then
                echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin)['choices'][0]['message']['content'])"
            elif [ "$AI_JSON_GET" == "sed" ]; then
                echo "$response" | sed -E 's/.*"content":"([^"]*)".*/\1/' | awk '{gsub(/\\n/, "\n")}1'
            elif [ "$AI_JSON_GET" == "jq" ]; then
                echo "$response" | jq -r '.choices[0].message.content'
            elif [ "$AI_JSON_GET" == "grep" ]; then
                echo "$response" | grep -oP '"content":"\K[^"]*'
            fi
            
            echo "----------------------------------"
            bash_end
            ;;
        "$BASH_OPTION -M")
            bash_typeof2
            ;;
        "help")
            BASH_TITLE="help"
            bash_title "$SHUSERS:~/ $BASH_TITLE"
            bash_help
            bash_typeof
            ;;
        "$BASH_OPTION .")
            bash_testservers2
            ;;
        "$BASH_OPTION")
            bash_help
            bash_typeof
            ;;
        "")
            bash_typeof
            ;;
        "pacman")
            bash_help
            bash_typeof
            bash_typeof
            ;;
        " ")
            bash_typeof
            ;;
        *)
            echo "not found!. please use 'help'"
            bash_typeof
            ;;
    esac
}

packageManager()
{
    local PACMAN="ppman"

    case "$OPBASH_PF" in
        "$PACMAN -S")
            BASH_TITLE="PawnCLIS Package Manager (Sync)"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            local PLUGIN_DIR="plugins"
            local PACKAGE_FILE="package.json"
            local SERVER_CFG="server.cfg"

            if [ ! -f "$PACKAGE_FILE" ]; then
                echo -n "$(bash_coltext_r "error: ")"
                echo "package.json not found"
                
                cat > package.json <<EOF
{
    "package": [
        "github/example/user/repository",
        "github/example/user/repository/to/files/.zip",
        "github/example/user/repository/to/files/.tar.gz",
        "gitlab/example/user/repository",
        "gitlab/example/user/repository/to/files/.zip",
        "gitlab/example/user/repository/to/files/.tar.gz"
    ]
}
EOF

                bash_typeof2
            fi

            URLS=$(awk -F '"' '/package/ {getline; while ($0 ~ /"/) {print $2; getline}}' "$PACKAGE_FILE")

            for REPO_URL in $URLS; do
                echo "Processing repository: $REPO_URL..."

                if [[ "$REPO_URL" != https://* ]]; then
                    if [[ "$REPO_URL" == github/* ]]; then
                        REPO_URL="https://github.com/${REPO_URL#github/}"
                    elif [[ "$REPO_URL" == gitlab/* ]]; then
                        REPO_URL="https://gitlab.com/${REPO_URL#gitlab/}"
                    fi
                fi

                if [[ "$REPO_URL" == *"/releases/download/"* ]]; then
                    ARCHIVE_URL="$REPO_URL"
                elif [[ "$REPO_URL" == *"/releases/tag/"* ]]; then
                    REPO_NAME=$(echo "$REPO_URL" | awk -F '/' '{print $(NF-3) "/" $(NF-2)}')
                    TAG_VERSION=$(echo "$REPO_URL" | awk -F '/' '{print $NF}')
                    
                    if [[ "$REPO_URL" == *"github.com"* ]]; then
                        API_URL="https://api.github.com/repos/$REPO_NAME/git/refs/tags/$TAG_VERSION"
                    elif [[ "$REPO_URL" == *"gitlab.com"* ]]; then
                        API_URL="https://gitlab.com/api/v4/projects/${REPO_NAME//\//%2F}/releases/$TAG_VERSION"
                    else
                        echo "Unsupported repository host."
                        bash_typeof2
                    fi
                    
                    ARCHIVE_URL=$(curl -s "$API_URL" | grep -o '"browser_download_url":"[^"]*"' | awk -F '"' '{print $4}' | head -n 1)
                else
                    if [[ "$REPO_URL" == *"github.com"* ]]; then
                        ARCHIVE_URL="$REPO_URL/archive/refs/heads/master.zip"
                    elif [[ "$REPO_URL" == *"gitlab.com"* ]]; then
                        ARCHIVE_URL="$REPO_URL/-/archive/master/master.zip"
                    else
                        echo "Unsupported repository host."
                        bash_typeof2
                    fi
                fi

                ARCHIVE_FILE=".repo_temp.zip"
                EXTRACT_DIR=".repo_extracted"

                rm -rf "$EXTRACT_DIR"
                mkdir -p "$EXTRACT_DIR"

                echo -n "$(bash_coltext_y "info: ")"
                echo "Downloading: $ARCHIVE_URL..."

                if [ "$PPMAN_INSTALLER" == "urllib3" ]; then
                    python3 -c "import urllib3; http=urllib3.PoolManager(); r=http.request('GET', '$ARCHIVE_URL', preload_content=False); f=open('$ARCHIVE_FILE', 'wb'); [f.write(chunk) for chunk in r.stream(1024)]; f.close(); r.release_conn()"
                elif [ "$PPMAN_INSTALLER" == "curl" ]; then
                    curl -sL "$ARCHIVE_URL" -o "$ARCHIVE_FILE"
                fi

                if file "$ARCHIVE_FILE" | grep -q "Zip archive data"; then
                    unzip -q "$ARCHIVE_FILE" -d "$EXTRACT_DIR"
                elif file "$ARCHIVE_FILE" | grep -q "gzip compressed data"; then
                    mkdir -p "$EXTRACT_DIR"
                    tar -xzf "$ARCHIVE_FILE" -C "$EXTRACT_DIR" --strip-components=1
                else
                    echo -n "$(bash_coltext_r "error: ")"
                    echo "Downloaded file is not a valid ZIP or TAR.GZ archive"
                    rm -rf "$ARCHIVE_FILE" "$EXTRACT_DIR"
                    continue
                fi

                EXTRACTED_SUBDIR=$(find "$EXTRACT_DIR" -mindepth 1 -maxdepth 1 -type d | head -n 1)
                
                if [[ -d "$EXTRACTED_SUBDIR" ]]; then
                    mv "$EXTRACTED_SUBDIR"/* "$EXTRACT_DIR/"
                    rm -rf "$EXTRACTED_SUBDIR"
                fi

                echo -n "$(bash_coltext_y "info: ")"
                echo "Extraction Directory.."

                find "$EXTRACT_DIR" -type f -name "*.inc" | while IFS= read -r inc_file; do
                    rel_path=$(realpath --relative-to="$EXTRACT_DIR" "$inc_file" 2>/dev/null || echo "$inc_file")

                    if [[ "$rel_path" =~ (^|/)include/ ]]; then
                        rel_path="${rel_path#*include/}"
                    fi

                    if [[ "$rel_path" == */* ]]; then
                        dest_path="$ALLOW_INC_DIR/$(dirname "$rel_path")"
                    else
                        dest_path="$ALLOW_INC_DIR"
                    fi

                    mkdir -p "$dest_path"
                    mv "$inc_file" "$dest_path/"
                done

                find "$EXTRACT_DIR" -type f \( -name "*.dll" -o -name "*.so" \) -exec mv {} "$PLUGIN_DIR/" \;

                rm -rf "$ARCHIVE_FILE" "$EXTRACT_DIR"
                echo -n "$(bash_coltext_y "info: ")"
                echo "Installation complete for $REPO_URL!"
            done

            echo -n "$(bash_coltext_y "[All packages installed]")"
            echo

            mkdir -p "$PLUGIN_DIR"

            if [ ! -f "$SERVER_CFG" ]; then
                echo -n "$(bash_coltext_r "error: ")"
                echo "$SERVER_CFG not found! Creating a new one."
                echo "plugins " > "$SERVER_CFG"
            fi

            EXISTING_PLUGINS=$(grep -oP '(?<=plugins ).*' "$SERVER_CFG" | tr ' ' '\n' | sort -u)

            NEW_PLUGINS=()
            for FILE in "$PLUGIN_DIR"/*.{so,dll}; do
            if [ -e "$FILE" ]; then
                PLUGIN_NAME=$(basename "$FILE" | sed 's/\.[^.]*$//')
                if ! echo "$EXISTING_PLUGINS" | grep -qx "$PLUGIN_NAME"; then
                NEW_PLUGINS+=("$PLUGIN_NAME")
                fi
            fi
            done

            if [ ${#NEW_PLUGINS[@]} -gt 0 ]; then
                UPDATED_PLUGINS=$(echo "$EXISTING_PLUGINS" "${NEW_PLUGINS[@]}" | tr '\n' ' ' | xargs -n1 | sort -u | xargs)
                sed -i "s/^plugins .*/plugins $UPDATED_PLUGINS/" "$SERVER_CFG"
                echo "Added new plugins to server.cfg: ${NEW_PLUGINS[*]}"
            else
                echo -n "$(bash_coltext_y "info: ")"
                echo "No new plugins need to be added."
            fi
            bash_typeof2
            ;;
        "$PACMAN -u")
            BASH_TITLE="PawnCLIS Package Manager (Updates)"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            local PLUGIN_DIR="plugins"
            local PACKAGE_FILE="package.json"

            if [ ! -f "$PACKAGE_FILE" ]; then
                echo -n "$(bash_coltext_r "error: ")"
                echo "package.json not found"
                echo

                cat > package.json <<EOF
{
    "package": [
        "github/example/user/repository",
        "github/example/user/repository/to/files/.zip",
        "github/example/user/repository/to/files/.tar.gz",
        "gitlab/example/user/repository",
        "gitlab/example/user/repository/to/files/.zip",
        "gitlab/example/user/repository/to/files/.tar.gz"
    ]
}
EOF

                bash_typeof2
            fi

            mkdir -p "$PLUGIN_DIR"

            URLS=$(awk -F '"' '/package/ {getline; while ($0 ~ /"/) {print $2; getline}}' "$PACKAGE_FILE")

            for REPO_URL in $URLS; do
                echo "Processing repository: $REPO_URL..."

                if [[ "$REPO_URL" != https://* ]]; then
                    if [[ "$REPO_URL" == github/* ]]; then
                        REPO_URL="https://github.com/${REPO_URL#github/}"
                    elif [[ "$REPO_URL" == gitlab/* ]]; then
                        REPO_URL="https://gitlab.com/${REPO_URL#gitlab/}"
                    fi
                fi

                if [[ "$REPO_URL" == *"/releases/download/"* ]]; then
                    ARCHIVE_URL="$REPO_URL"
                elif [[ "$REPO_URL" == *"/releases/tag/"* ]]; then
                    REPO_NAME=$(echo "$REPO_URL" | awk -F '/' '{print $(NF-3) "/" $(NF-2)}')
                    TAG_VERSION=$(echo "$REPO_URL" | awk -F '/' '{print $NF}')
                    
                    if [[ "$REPO_URL" == *"github.com"* ]]; then
                        API_URL="https://api.github.com/repos/$REPO_NAME/git/refs/tags/$TAG_VERSION"
                    elif [[ "$REPO_URL" == *"gitlab.com"* ]]; then
                        API_URL="https://gitlab.com/api/v4/projects/$(echo "$REPO_NAME" | tr '/' '%2F')/releases/$TAG_VERSION"
                    else
                        echo "Unsupported repository host."
                        bash_typeof2
                    fi

                    ARCHIVE_URL=$(curl -s "$API_URL" | grep "browser_download_url" | grep -E ".zip|.tar.gz" | awk -F '"' '{print $4}' | head -n 1)
                else
                    REPO_NAME=$(echo "$REPO_URL" | awk -F '/' '{print $(NF-1) "/" $NF}')
                    
                    if [[ "$REPO_URL" == *"github.com"* ]]; then
                        API_URL="https://api.github.com/repos/$REPO_NAME/git/refs/tags/$TAG_VERSION"
                    elif [[ "$REPO_URL" == *"gitlab.com"* ]]; then
                        API_URL="https://gitlab.com/api/v4/projects/$(echo "$REPO_NAME" | tr '/' '%2F')/releases/permalink/latest"
                    else
                        echo "Unsupported repository host."
                        bash_typeof2
                    fi

                    ARCHIVE_URL=$(curl -s "$API_URL" | grep "browser_download_url" | grep -E ".zip|.tar.gz" | awk -F '"' '{print $4}' | head -n 1)
                fi

                if [[ -z "$ARCHIVE_URL" ]]; then
                    echo -n "$(bash_coltext_y "info: ")"
                    echo "No release found, downloading source master..."
                    ARCHIVE_URL="${REPO_URL}/archive/refs/heads/master.zip"
                fi

                local ARCHIVE_FILE=".repo_temp"
                local EXTRACT_DIR=".repo_extracted"

                rm -rf "$EXTRACT_DIR"
                mkdir -p "$EXTRACT_DIR"

                echo -n "$(bash_coltext_y "info: ")"
                echo "Downloading: $ARCHIVE_URL..."
                
                if [ "$PPMAN_INSTALLER" == "urllib3" ]; then
                    python3 -c "import urllib3; http=urllib3.PoolManager(); r=http.request('GET', '$ARCHIVE_URL', preload_content=False); f=open('$ARCHIVE_FILE', 'wb'); [f.write(chunk) for chunk in r.stream(1024)]; f.close(); r.release_conn()"
                elif [ "$PPMAN_INSTALLER" == "curl" ]; then
                    curl -sL "$ARCHIVE_URL" -o "$ARCHIVE_FILE"
                fi

                if file "$ARCHIVE_FILE" | grep -q "Zip archive data"; then
                    echo "Extracting ZIP file..."
                    unzip -q "$ARCHIVE_FILE" -d "$EXTRACT_DIR"
                elif file "$ARCHIVE_FILE" | grep -q "gzip compressed data"; then
                    echo "Extracting TAR.GZ file..."
                    mkdir -p "$EXTRACT_DIR"
                    tar -xzf "$ARCHIVE_FILE" -C "$EXTRACT_DIR" --strip-components=1
                else
                    echo "error: Downloaded file is not a valid ZIP or TAR.GZ archive"
                    rm -rf "$ARCHIVE_FILE" "$EXTRACT_DIR"
                    continue
                fi

                echo -n "$(bash_coltext_y "info: ")"
                echo "Extraction Directory.."

                find "$EXTRACT_DIR" -type f -name "*.inc" -exec bash -c '
                    for inc_file; do
                        rel_path=$(realpath --relative-to="$1" "$inc_file" 2>/dev/null || echo "$inc_file")
                        dest_path="$2"

                        if [[ "$rel_path" == include/* ]]; then
                            rel_path="${rel_path#*/}"
                        fi

                        if [[ "$rel_path" == */* ]]; then
                            dest_path="$2/$(dirname "$rel_path")"
                        fi

                        mkdir -p "$dest_path"
                        mv "$inc_file" "$dest_path/"
                    done
                ' _ "$EXTRACT_DIR" "$ALLOW_INC_DIR" {} +

                find "$EXTRACT_DIR" -type f \( -name "*.dll" -o -name "*.so" \) -exec mv {} "$PLUGIN_DIR/" \;

                rm -rf "$ARCHIVE_FILE" "$EXTRACT_DIR"
                echo "Update completed for $REPO_URL!"
            done

            echo -n "$(bash_coltext_y "[All packages have been updated]")"

            bash_typeof2
            ;;
        "$PACMAN -r")
            BASH_TITLE="PawnCLIS Package Manager (Remove)"
            bash_title "$SHUSERS:~/ $BASH_TITLE"

            local PLUGIN_DIR="plugins"
            local SERVER_CFG="server.cfg"

            echo "Enter the name pattern of the include/plugin to remove:"
            read -r REMOVE_PATTERN

            filter_files() {
                local pattern="$1"
                while read -r file; do
                    filename=$(basename "$file")
                    if [[ "$filename" =~ ^$pattern(\.[a-z]+)?$ || "$filename" =~ .*-?$pattern(\.[a-z]+)?$ ]]; then
                        echo "$file"
                    fi
                done
            }

            INC_FILES=$(find "$ALLOW_INC_DIR" -type f -name "*.inc" | filter_files "$REMOVE_PATTERN")

            if [[ -n "$INC_FILES" ]]; then
                echo "$INC_FILES" | xargs rm -rf
                echo -n "$(bash_coltext_y "[OK] ")"
                echo "Removed includes: $INC_FILES"
            else
                echo -n "$(bash_coltext_y "info: ")"
                echo "No matching include files found for pattern: $REMOVE_PATTERN"
            fi

            PLUGIN_FILES=$(find "$PLUGIN_DIR" -type f \( -name "*.dll" -o -name "*.so" \) | filter_files "$REMOVE_PATTERN")

            if [[ -n "$PLUGIN_FILES" ]]; then
                echo "$PLUGIN_FILES" | xargs rm -rf
                echo -n "$(bash_coltext_y "[OK] ")"
                echo "Removed plugins: $PLUGIN_FILES"
            else
                echo -n "$(bash_coltext_y "info: ")"
                echo "No matching plugins found for pattern: $REMOVE_PATTERN"
            fi

            if [[ -f "$SERVER_CFG" ]]; then
                if grep -q "^plugins" "$SERVER_CFG"; then
                    sed -i "/^plugins /s/\b$REMOVE_PATTERN\b//g" "$SERVER_CFG"
                    sed -i 's/  / /g' "$SERVER_CFG"
                    sed -i 's/^plugins *$/plugins /' "$SERVER_CFG"
                    echo -n "$(bash_coltext_y "[OK] ")"
                    echo "Removed $REMOVE_PATTERN from server.cfg"
                else
                    echo -n "$(bash_coltext_y "info: ")"
                    echo "No 'plugins' entry found in server.cfg"
                fi
            else
                echo "error: server.cfg not found!"
            fi

            echo -n "$(bash_coltext_y "[OK] ")"
            echo "Removal process completed!"
            bash_typeof2
            ;;
        "$PACMAN")
            bash_help2
            bash_typeof2
            ;;
        "$PACMAN ")
            bash_help2
            bash_typeof2
            ;;
        "help")
            bash_help2
            bash_typeof2
            ;;
        "$PACMAN -E")
            bash_typeof
            ;;
        *)
            echo "not found!. please use 'help'"
            bash_typeof2
            ;;
    esac
}

function bash_help()
{
    echo "Usage: paw <command> [<options>...]"
    echo ""
    echo "Commonly used commands can be classified as follows:"
    echo ""
    echo "    Basic Operations:"
    echo "        compile     (-c)   Compile a project."
    echo "        running     (-r)   Check if a process is running."
    echo "        debugger    (-d)   Start a debugger server."
    echo "        stop        (-s)   Stop a server."
    echo "        compile-run (-u)   Compile and run a project."
    echo "        download-gm (-g)   Download a gamemode."
    echo "        download-pc (-p)   Download pawncc."
    echo "        clear       (-C)   Clear the screen."
    echo "        checksums   (-S)   Generate or verify checksums."
    echo "        folder-check(-F)   Check a folder's integrity."
    echo "        vscode-tasks(-V)   Generate VSCode tasks."
    echo "        type-file   (-T)   Display file type."
    echo "        whoami      (-W)   Display current user."
    echo "        kill-cmd    (-K)   Kill a command."
    echo "        directory   (-D)   Change or display the current directory."
    echo "        version     (-v)   Display tool version."
    echo "        update      (-U)   Update the tool."
    echo "        exit        (-e)   Exit or start a bash shell."
    echo "        ask-ai      (-a)   Ask an AI for assistance."
    echo "        ppman       (-M)   Enter PawnCLIS Package Manager Mode."
    echo ""
    echo "    Package Management:"
    echo "        sync        (-S)   Synchronize and install/replace packages. (ppman)"
    echo "        update      (-u)   Update packages. (ppman)"
    echo "        remove      (-r)   Remove packages. (ppman)"
    echo "        end         (-E)   End PawnCLIS Package Manager Mode."
    echo ""
}

function bash_help2()
{
    echo "    Package Management:"
    echo "        sync        (-S)   Synchronize and install/replace packages. (ppman)"
    echo "        update      (-u)   Update packages. (ppman)"
    echo "        remove      (-r)   Remove packages. (ppman)"
    echo "        end         (-E)   End PawnCLIS Package Manager Mode."
    echo ""
}

function bash_end() {
    echo -n "$(bash_coltext_y "Press any key to return.")"
    echo
    read -r -n 1 -s
    bash_typeof
}

function bash_servers() {
    if [ -f "$BASH_DIR/server_log.txt" ]; then
        rm -rf "$BASH_DIR/server_log.txt"
    fi
    if [ ! -f "$BASH_SERVER" ]; then
        echo
        echo "# $BASH_SERVER not found.."
        BASH_SEND_SAMP_STATUS=1
        bash_send_samp
    fi
    chmod 777 $BASH_SERVER
    ./samp-server.exe &
    sleep 2
    if ! pgrep -x "samp-server.exe" >/dev/null; then
        BASH_TITLE="running - failed"
        bash_title "$SHUSERS:~/ $BASH_TITLE"
        echo
        echo -n "$(bash_coltext_r "# Fail")"
        echo
        if [ -f "server_log.txt" ]; then
            sleep 2
            cat server_log.txt
            echo
        else
            echo "# server_log.txt not found."
        fi
        echo -n "$(bash_coltext_y "# End.")"
        echo
        bash_typeof
    else
        echo
        echo -n "$(bash_coltext_y "# Success")"
        echo
        sleep 2
        if grep -i "error" server_log.txt >/dev/null; then
            start_true
        else
            start_false
        fi
    fi
}

function bash_testservers() {
    if [ -f "$BASH_DIR/server_log.txt" ]; then
        rm -rf "$BASH_DIR/server_log.txt"
    fi
    if [ ! -f "$BASH_SERVER" ]; then
        echo
        echo "# $BASH_SERVER not found.."
        BASH_SEND_SAMP_STATUS=2
        bash_send_samp
    else
        chmod 777 $BASH_SERVER
        ./samp-server.exe &
        sleep 1
        cat server_log.txt
        echo
        killall -9 "samp-server.exe" >/dev/null 2>&1
    fi
    bash_end
}

function bash_testservers2() {
    if [ ! -f "server.cfg" ]; then
        echo "server.cfg not found!"
        exit 1
    fi

    mv server.cfg server.cfg.bak

    echo -n "Enter gamemode name: "
    read -r GAMEMODE_NAME

    awk -v new_gamemode="$GAMEMODE_NAME" '
    /^gamemode0 / {$2=new_gamemode} 1' server.cfg.bak > server.cfg

    echo "New server.cfg created with gamemode: $GAMEMODE_NAME"

    if [ ! -f "$BASH_SERVER" ]; then
        echo
        echo "# $BASH_SERVER not found.."
        BASH_SEND_SAMP_STATUS=2
        bash_send_samp
    else
        chmod 777 "$BASH_SERVER"
        ./samp-server.exe &
        sleep 1
        cat server_log.txt
        echo
        killall -9 "samp-server.exe" >/dev/null 2>&1
    fi

    rm -f server.cfg
    mv server.cfg.bak server.cfg
    echo "Original server.cfg has been restored."

    bash_end
}

function bash_compilers() {
    SHFILE=false
    
    while IFS= read -r -d '' pawncc; do
    if [ -f "$pawncc" ]; then
        COMPILER_PAWNCC="$pawncc"
        break
    fi
    done < <(find "$BASH_DIR" -name "pawncc.exe" -print0)

    if [ -z "$COMPILER_PAWNCC" ]; then
        echo "# pawncc not found.."
        echo
        BASH_SEND_PAWNCC_STATUS=1
        bash_send_compiler
    fi

    mapfile -d '' files < <(find "$BASH_DIR" -name "*.io*" -type f -print0)

    for file in "${files[@]}"; do
        if [ -f "$file" ] && [[ "$file" != *.amx ]]; then
            SHFILE=true
            bash_title "$file"

            AMX_O="$(dirname "$file")/$(basename "${file%.io*}.amx")"

            echo "Processing: $file"

            "$COMPILER_PAWNCC" -i"$BASH_DIR$BASH_ALLOW_SDIR" "$file" -o"$AMX_O" "$AMX_OPT_F" > "$METADAT_FILE" 2>&1
            EXIT_STATUS=$?

            if [ $EXIT_STATUS -ne 0 ] || grep -q "fatal error" "$METADAT_FILE"; then
                echo "Compilation failed with exit code: $EXIT_STATUS"
                [ -f "$AMX_O" ] && rm -rf "$AMX_O"
            fi

            _cache_compiler
            sleep 0
            cat "$METADAT_FILE"

            if [ -s "$AMX_O" ]; then
                echo
                echo "~ $AMX_O"
                if [ "$COMPILER_MODE" == "true" ]; then
                    BASH_TITLE="compilers"
                    bash_title "$SHUSERS:~/ $BASH_TITLE"
                elif [ "$COMPILER_MODE" == "false" ]; then
                    BASH_TITLE="compiler - running"
                    bash_title "$SHUSERS:~/ $BASH_TITLE"
                fi
                echo "total size : $(stat -c%s "$AMX_O") bytes"
                echo
            else
                if [ "$COMPILER_MODE" == "false" ]; then
                    bash_end
                fi
            fi
        fi
    done

    if [ "$SHFILE" == "false" ]; then
        echo -n "$(bash_coltext_r "..io not found!")"
        echo
        bash_end
    fi
    if [ "$COMPILER_MODE" == "true" ]; then
        bash_end
    elif [ "$COMPILER_MODE" == "false" ]; then
        ok_next
    fi
}

function _cache_compiler() {
    cache_compiler=".cache/compiler.log"
    _cache_compiler=".cache/.compiler.log"
    if [ -f "$_cache_compiler" ]; then
        rm -rf "$_cache_compiler"
    fi
    while IFS= read -r line; do
        echo "~" >> "$_cache_compiler"
        echo "$line" >> "$_cache_compiler"
    done < "$cache_compiler"
    mv "$_cache_compiler" "$cache_compiler" >/dev/null
}

function CHECK_FOL_NOW() {
    local folder=$1
    if [ -d "$folder" ]; then
        echo
        echo "# $folder is .. Ok .."
        echo " [A subdirectory or file $folder already exists.]"
        echo "-"
        sleep 1
    else
        mkdir -p "$folder"
        echo "OK? '$BASH_DIR/$folder'...: [yes]"

        cat <<EOF > gamemodes/main.io.pwn
#include <a_samp>

main() {
    print("Hello, World!");
}
EOF
        sleep 1
    fi
}

function start_true() {
    echo -n "$(bash_coltext_r "~")"
    echo "    ; \"error\"   .. Yes .. True"
    error_cache
}

function start_false() {
    echo -n "$(bash_coltext_y "~")"
    echo "    ; \"error\"   .. No .. False"
    check2
}

function check2() {
    if grep -i "failed" server_log.txt >/dev/null; then
        start_true2
    else
        start_false2
    fi
}

function start_true2() {
    echo -n "$(bash_coltext_r "~")"
    echo "    ; \"failed\"  .. Yes .. True"
    failed_cache
}

function start_false2() {
    echo -n "$(bash_coltext_y "~")"
    echo "    ; \"failed\"  .. No .. False"
    check3
}

function check3() {
    if grep -i "invalid" server_log.txt >/dev/null; then
        start_true3
    else
        start_false3
    fi
}

function start_true3() {
    echo -n "$(bash_coltext_r "~")"
    echo "    ; \"invalid\" .. Yes .. True"
    invalid_cache
}

function start_false3() {
    echo -n "$(bash_coltext_y "~")"
    echo "    ; \"invalid\" .. No .. False"
    echo
    bash_end
}

function error_cache() {
    echo
    grep -i "error" server_log.txt
    echo
    check2
}

function failed_cache() {
    echo
    grep -i "failed" server_log.txt
    echo
    check3
}

function invalid_cache() {
    echo
    grep -i "invalid" server_log.txt
    echo
    bash_end
}

function ok_next() {
    echo -n "$(bash_coltext_y "Press any key to running.")"
    echo
    read -r -n 1 -s
    bash_servers
}

function bash_send_samp()
{
    echo "Do you want to continue downloading SA-MP? (Yy/Nn)"
    read -r -p ">> " SEL_C
    if [[ "$SEL_C" =~ ^[Yy]$ ]]; then
        cd "$BASH_DIR" || bash_end
        echo "Select the SA-MP version to download:"
        echo "[A/a] SA-MP 0.3.7 R2-1-1"
        echo "[B/b] SA-MP 0.3.7 R3"
        echo "[C/c] SA-MP 0.3.DL R1"
        read -r -p ">> " _VERSION_
        case "$_VERSION_" in
            [Aa])
                URL_CURL="https://files.sa-mp.app/samp037_svr_R2-1-1_win32.zip"
                FILE_CURL="samp037_svr_R2-1-1_win32.zip"
                ;;
            [Bb])
                URL_CURL="https://files.sa-mp.app/samp037_svr_R3_win32.zip"
                FILE_CURL="samp037_svr_R3_win32.zip"
                ;;
            [Cc])
                URL_CURL="https://sa-mp.co.id/files/samp03DL_svr_R1_win32.zip"
                FILE_CURL="samp03DL_svr_R1_win32.zip"
                ;;
            *)
            echo -n "$(bash_coltext_r "error: ")"
            echo "Invalid selection. Please enter A, B, or C."
            ;;
        esac
        echo -e "\nDownloading: $URL_CURL -> $FILE_CURL"
        if ! curl -L --progress-bar -o "$FILE_CURL" "$URL_CURL"; then
            echo "failed: Failed to download the file.."
            echo "failed: Failed to download the file.."

            BASH_SEND_SAMP_STATUS=0
            if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
                bash_servers
            elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
                bash_testservers
            elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
                bash_end
            fi
        else
            unzip -q "$FILE_CURL" -d "$BASH_DIR"
            echo
            echo -n "$(bash_coltext_y "Download completed successfully.")"
            echo
            echo "Please rename \"rcon_password\" before running this command again"

            BASH_SEND_SAMP_STATUS=0
            if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
                bash_servers
            elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
                bash_testservers
            elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
                bash_end
            fi
        fi
    else
        BASH_SEND_SAMP_STATUS=0
        if [ $BASH_SEND_SAMP_STATUS == 1 ]; then
            bash_servers
        elif [ $BASH_SEND_SAMP_STATUS == 2 ]; then
            bash_testservers
        elif [ $BASH_SEND_SAMP_STATUS == 0 ]; then
            bash_end
        fi
    fi
}

function bash_send_compiler()
{
    echo "Do you want to continue downloading PawnCC? (Yy/Nn)"
    read -r -p ">> " SEL_C
    if [[ "$SEL_C" =~ ^[Yy]$ ]]; then
        cd "$BASH_DIR" || bash_end
        echo "Select the PawnCC version to download:"
        echo "[A/a] PawnCC 3.10.10"
        echo "[B/b] PawnCC 3.10.9"
        echo "[C/c] PawnCC 3.10.8"
        echo "[D/d] PawnCC 3.10.7"
        echo "[E/e] PawnCC 3.10.6"
        echo "[F/f] PawnCC 3.10.5"
        read -r -p ">> " _VERSION_
        case "$_VERSION_" in
            [Aa])
                URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.10/pawnc-3.10.10-windows.zip"
                FILE_CURL="pawnc-3.10.10-windows.zip"
                ;;
            [Bb])
                URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.9/pawnc-3.10.9-windows.zip"
                FILE_CURL="pawnc-3.10.9-windows.zip"
                ;;
            [Cc])
                URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.8/pawnc-3.10.8-windows.zip"
                FILE_CURL="pawnc-3.10.8-windows.zip"
                ;;
            [Dd])
                URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.7/pawnc-3.10.7-windows.zip"
                FILE_CURL="pawnc-3.10.7-windows.zip"
                ;;
            [Ee])
                URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.6/pawnc-3.10.6-windows.zip"
                FILE_CURL="pawnc-3.10.6-windows.zip"
                ;;
            [Ff])
                URL_CURL="https://github.com/pawn-lang/compiler/releases/download/v3.10.5/pawnc-3.10.5-windows.zip"
                FILE_CURL="pawnc-3.10.5-windows.zip"
                ;;
            *)
            echo -n "$(bash_coltext_r "error: ")"
            echo "Invalid selection. Please enter A, B, C, D, or E, F."
            return
            ;;
        esac
        echo -e "\nDownloading: $URL_CURL -> $FILE_CURL"
        if ! curl -L --progress-bar -o "$FILE_CURL" "$URL_CURL"; then
            echo "failed: Failed to download the file.."

            BASH_SEND_PAWNCC_STATUS=0
            if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
                bash_compilers
            elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
                bash_end
            fi
        else
            unzip -q "$FILE_CURL" -d "$BASH_DIR"
            echo
            echo -n "$(bash_coltext_y "Download completed successfully.")"
            echo

            BASH_SEND_PAWNCC_STATUS=0
            if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
                bash_compilers
            elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
                bash_end
            fi
        fi
    else
        BASH_SEND_PAWNCC_STATUS=0
        if [ $BASH_SEND_PAWNCC_STATUS == 1 ]; then
            bash_compilers
        elif [ $BASH_SEND_PAWNCC_STATUS == 0 ]; then
            bash_end
        fi
    fi
}

bash_typeof
